Is there anybody out there ? - Manuel Bernhardt :

Lot of uncertainy on the status of other nodes in a network
Key issues for building clusters :
  - Discovery
  - Fault detection
  - Load balancing
-> Group memebership : failure detection / dissemination / consensus

Failure detection :
Failure detector key propreties :
  - Completeness : when a node crashes, all other nodes have to know that the node failed
  - Accurracy : No false-postive

It is impossible for a failrue detector achieve both completeness and accuracy over an asynchronous unreliable network

En général, on choisit une "completeness" forte avec une "accuracy" plus faible.

2 méthodes pour un "failure detector" : heartbeat / ping

(Phi/New Adaptive Accrual Failure Detector)
-> SWIM Failure Detector : members are first flagged as suspected before being declared dead
Principe:
  - Ping aléatoire d'une machine à une autre
  - Si la machine pingée ne répond pas, la machine est suspectée et des ping-reqs sont envoyés à d'autres machines
  - Les machines qui reçoivent les ping-req pingent à leurs tour la première machine pingée
  - Si la machine répond, elle n'est plus suspectée, sinon elle est déclarée morte
  --> Looooooot of false-Positive
    -->Lifeguard Failure Detector / Rapid (for large clusters)

Dissemintation :
  - We don't do multicast
  - Gossip protocols (most popular random ping protocol ; infection-style ; round-robin...)

"Sum of gossip tables" -> si une machine reste non contactée depuis un moment, elle est peut-être morte
There is gossip optimizations (Akka Cluster / Lifeguard ...)

Consensus :
Group membership with a singl group is impossible when there are nodes that are suspected of having failed
  -> It would be unwise to make membership-related decisions while there are processes sispected of having crashed
*Bout de code dans la vidéo*
Reaching consensus :
  - time : Lamport/Vector/Version Vectors clocks
  - replicated state machines : method to synchronize state between machines
  - protocols : fault-tolerant distributed systems -> make multiple servers agree on a value
  - CRDTs :strong eventual consistency
  - conventions : (solve conflicts by adresses...)

Pour MUTE :
  - Failure dectector : à moi de la faire (membership protocol)
  - Dissemination : rejoindre une session en cliquant sur un lien ?
  - Consensus : CRDTs

*Expérience dans la vidéo*

--------------------------------
SWIM:
Main advantages of SWIM :
  (1) imposes a constant message load per group member;
  (2) detects a process failure in an (expected) constant time at some non-faulty process in the group;
  (3) provides a deterministic bound (as a function of group size) on the local time that a non-faulty process takes to detect failure of another process;
  (4) propagates membership updates, including information about failures, in infection-style (also gossip-style or
    epidemic-style [2, 8]); the dissemination latency in the group grows slowly (logarithmically) with the number of members;
  (5) provides a mechanism to reduce the rate of false positives by “suspecting” process before “declaring” it as failed within the group.

SWIM approach has two components:
  (1) a Failure Detector Component, that detects failures of
  members, and
  (2) a Dissemination Component, that disseminates informa-
  tion about members that

SWIM Failure Detector :
  2 parameters : T = protocol period / k = size of failure detection subgroup
  Note that the protocol period T has to beat least three times the round-trip estimate

Infection-Style Dissemination Component : (Multicast is too unrelaible)
  ... [SWIM] does so by piggybacking the information to be disseminated on the ping, ping-req and ack messages generated by the failure detector protocol.
  These analyses also show that the infection style of dissemination is resilient to process failures and loss of messages within the network

Override rules :
  • {Alive M l , inc = i} overrides
  – {Suspect M l , inc = j}, i > j
  – {Alive M l , inc = j}, i > j
  • {Suspect M l , inc = i} overrides
  – {Suspect M l , inc = j}, i > j
  – {Alive M l , inc = j}, i ≥ j
  • {Confirm M l , inc = i} overrides
  – {Alive M l , inc = j}, any j
  – {Suspect M l , inc = j}, any j

Round-Robin Probe Target Selection: Providing Time-Bounded Strong Completeness

Graphiques intéressant à la fin du document

--------------------------------
Make your cluster SWIM :
  La partie théorique reste la même que dans le doc précédent, mais la partie pratique sera très utile pour pour plus tard
